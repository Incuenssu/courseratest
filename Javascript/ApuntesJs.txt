Variables
	Empieza siempre por "var"
		var message = "Hello World";
		var palabra = "1";
	No se declaran tipos en Javascript: Int, String, float, etc.
		Es por eso que se le llama dinamic typed language
		Same variable can hold different types during the life of the execution

Funciones
	Estructura:
		function NAME () {}
		var NAME = function () {}
	Tambien se puede definir una funcion como variable, es lo mismo escribir:
			function a () {}
		que escribir
			var a = function () {}		Aqui no se pone el name
	Para invocar una funcion:
		NAME();
		a();
	Arguments/parametros:
		function compare (x, y){
		return x>y;
		}
	JS permite hacer lo siguiente:
		function compare (x, y) {}; 	Tenemos la funcion comparar x e y
		var a = compare (4, 5);			Comparamos 4 y 5 y lo guardamos en a
		compare (4, "a");				Comparamos 4 y a, que es el resultado de comparar 4 y 5
		compare();						No comparamos nada, pero la sintaxis es correcta

Scope
	Global
		Variables and function defined here are available everywhere
	Function (aka lexical)
		Variables and function defined here are available only within this function
	Scope Chain:
		Everything is executed in an Execution Context
		Function invocation creates a new Execution Context
		Each Execution Context has:
			Its own Variable Environment
			Special "this" object
			Reference to its Outer Environment
		Global scope does not have an Outer Environment as it's the most outer there is
		How it works Scope Chain:
			Referenced (not defined) variable will be searched for in its corrent scope first.
			If not found, the Outer Reference will be searched.
			if not found, the Outer Reference's Outer Reference will be searched.
			Etc
			This will keep going the Global scope.
			If not foun in GLobal scope, the variable is undefined.
		Example:
			Global
				var x = 2;
				A();
			Function A
				var x = 5;
				B();
			Function B
				console.log(x);
			The result printed is 2 porque la funcion B esta siendo llamada desde el Global, si fuese llamada(desde el inicio) en A, entonces el resultado seria 5.
			
JavasCript built-in Types (tipos integrados/incorporados en Javascript)
	A type is a particular data structure.
		Each language defines some built-in types.
		Built-in types can be used to build other data structures.
		Javascript has 7 built-in types: 6 primitives and 1 Object type
	Object is a collection of name/value pairs.
		Person object: (Ejemplo)
			firstname: 'Jose Luis', 	NAME(firstname) y VALUE(Jose Luis) 
			lastname: 'Gonzalez',		otro par de name/value
			social: {					NAME(social) y VALUE({lo de aqui dentro})
						linkedin : 'joseluisgonza',			otro par de name/value
						twitter: 'jolugo',					otro par de name/value
						facebook: 'JoseLuisGonalez',		otro par de name/value
					}
	Primitive type represents a single, inmutable value
		Single value, NOT an object
		Inmutable means once it's set, it can't be changed
			value becomes read-only
			you can create another value based on an exiting one
		Booleans: true or false
		Undefined: signifies that no value has ever been set
			you only have one value: undefined
			you can set a variable to undefined, but you should NEVER do it. 
				Its meaning is that it's never been defined, so defining it to undefined is counter to its core meaning
		Null: signifies lack of value
			as opposed to undefined, which is lack of definition
			can only have one value: null
			it's OK to explicitly set a variable to null
		Number: is the only numeric type in Javascript
			always represented under the hood as double-precision 64-bit floating point
			JS does not have an integer type
		String: is sequences of characters used to represent text
			use either single or double quotes. "text" or 'text'
	-->	Symbol: is new to ES6. 
			Not covered in this class
			ES6(realeased 2015) isn't widely supported or used yet

Common language constructs
	String concatination
		Podemos concatenar String con +=
			var palabra = "Hello";
			palabra += " ";
			palabra += "World";
			palabra += "!";					Es lo mismo que poner: palabra(Primer string, el de Hello) = palabra + " World!"
			console.log(palabra)				Resultado: Hello World!
			console.log(palabra + "!!!")		Resultado: Hello World!!!!
	Regular math operators
		+ - / *
		Tiene en cuenta todos los decimales:
			console.log((3*4)/233);		Resultado: 0.05150214592274678
		Si operamos con undefined, no da error, da un NaN(Not A Number)
			console.log(undefined/5);	Resultado: NaN
			Es comun definir una funcion que necesita una variable
				function test1(a){      
            		console.log(a/5)
        		}
        	Pero al llamar a la funcion no introducimos la variable y nos da como resultado NaN
        		test1();
        	OJO que no da error y nos deja correr JS
    Igualdad
    	== ===
    	Lo mismo que otros lenguajes
    		var x = 4, y = 4;					Esto es lo mismo que poner:
    		if (x == y) {							var x = 4;
        	console.log("x is equal to y")			var y = 4;
    		}				Resultado: x is equal to y
    	Pero, da igual el tipo de la variable que le hayamos asignado, JS modifica sus tipos para que sean iguales automaticamente
    		var y = 4;		Numero
    		var x = "4";	String
    		if (x == y) {
        		console.log("x is equal to y")
    		}				Resultado: x is equal to y
    	A no ser que queramos una igualdad estricta, con el triple igual, que entonces no variara sus tipos
    		var y = 4;		Numero
    		var x = "4";	String
    		if (x === y) {
        		console.log("X is equal to y")
    		}else{
        		console.log("X is NOT strict equal to y")
    		}				Resultado: X is NOT strict equal to y
    Verdadero o falso Boolean
    	Todo lo que JS considera false:
    		false
    		null
    		undefined
    		""			empty string
    		0
    		NaN
    	Todo lo que JS considera true:
    		true
    		"hello"
    		1
    		-1
    		"false"		This is a String with the word "false"
    	Si nos olvidamos podemos pasar por consola la siguiente orden:
    		Boolean(aqui ponemos nuestra duda);
    			Boolean(null);				false
    			Boolean(0);					false
    			Boolean("hey hey hey");		true
    Best practice for {} style
    	No se pone la apertura de llaves en una linea nueva, ya que da error. ya que es como poner un ;
    		function a() 			funntion a();
    		{
    			console.log("lo que sea")
    		}				Resultado: undefined
    	Se pone la apertura de llaves en la misma linea, y asi no da error.
    		function a() {
    			console.log("lo que sea")
    		}				Resultado: lo que sea
    Bucle FOR
    	Muy similar a Java:
    		for (var i = 0; i < 10; i++) {		de 0 a 9
        		ORDEN
    		}
    			i++ es lo mismo que i=i+1
    		for (var i = 0; i < 100; i=i*4) {		de 0 a 9
        		ORDEN
    		}
    Semicolons(;) in JS are optional
    	https://mislav.net/2010/05/semicolons/

Handling default values
	Si no metemos nada en una funcion obtenemos undefined
		function orderCHickeWith(sideDish) {
        	console.log("Chicken with " + sideDish)
    	}
    	orderCHickeWith("noodles")      //Chicken with noodles
    	orderCHickeWith()               //Chicken with undefined
    Para evitar el undefined podemos dar un valor por default
    	function orderCHickeWith(sideDish) {
        	if (sideDish === undefined) {
            	sideDish =  "nothing"
        	}
        	console.log("Chicken with " + sideDish)
    	}
    	orderCHickeWith("noodles")      //Chicken with noodles
    	orderCHickeWith()               //Chicken with nothing
    Pero JS tiene un shortcut para evitar poner el if
    	function orderCHickeWith(sideDish) {
        	sideDish = sideDish || "whatever!"      // El simbolo || es un OR
        	console.log("Chicken with " + sideDish)
    	}
    	orderCHickeWith("noodles")      //Chicken with noodles
    	orderCHickeWith()               //Chicken with whatever!
    Esto quiere decir que primero da el valor true:
    	Si sideDish = "" que es false
    		sideDish = sideDish || "whatever!"	-> false || true
    		usa "whatever!"
    	Si sideDish = 1 que es true
    		sideDish = sideDish || "whatever!"	-> true || true
    		usa 1
    	Es decir, utiliza SIEMPRE EL PRIMER TRUE

Objects
	Creation:
		var companey = new Object();
	Aunque no exista el metodo del objeto, JS lo crea:
		company.name = "Facebook"		Suponiendo que "name" no exista como metodo en el objeto
		Console.log(company)		Resultado: name: "Facebook"
									Es decir, no da error porque usemos un metodo que no existe
		Pero ojo con los puntos, que no autocrea los metodos
		company.ceo.firstname = "Mark"
		console.log(company)		Resultado: error
		company.ceo = new Object()
		company.ceo.firstname = "Mark"
		company["lastname"] = "Zuckenberg"
		var adress = "Valley of the death"
		company[adress] = 112
		console.log(company)		Resultado: name: "Facebook", ceo: Object {firstname: "Mark"} 
		Enlace:
		console.log(company.ceo.fistname)		Resultado: Mark
		console.log(company["name"])			Resultado: Facebook
	Simplificacion de creacion de objetos:
		Es mejor hacerlo con llaves:
			var facebook = {
        		name: "Facebook",
        		ceo: {
            		firstname: "Mark",
            		lastname: "Zuckenberg",
            		color: "blue"
        		},
        		"Stock of company": 110
    		}
    		OJO con las comas que son necesarias
    		console.log(facebook.ceo.firstname)		Resultado: Mark

Functions 			CORE FEATURE
	Functions in JS are objetcts
		function multiply(x, y){
    	    return x*y
    	}
    Podemos asignarles metodos:
    	multiply.version = "v1.0.0"
    	console.log(multiply.version)		Resultado: v1.0.0
    Function factory
    	Se pueden enlazar funciones unas con otras y crear unas dentro de otras:
    		function makemultiplier(multiplier){
		        var myFunc = function(x){
		            return multiplier * x;
		        };
		        return myFunc
		    }
		    var multiplyby3 = makemultiplier(3)
		    console.log(multiplyby3(10))
		    var doubleAll = makemultiplier(2)
		    console.log(doubleAll(100))
	Pasing functions as arguments
		Se pueden usar funciones como parametros
			function doOperationOn(x, operation){
		        return operation(x)
		    }
		    var result = doOperationOn(5, multiplyby3)
		    console.log(result)

Passing variable by value vs by reference
	Given b=a, passing/copying by VALUE means changing copied value in b DOES NOT AFFECT the value stored in a and visaversa
		Copiar/pasar el valor significa que el cambio en B no afecta a que cambie A y viceversa
	Given b=a, passing/copying by REFERENCE means changin copied value in b DOES AFFECT the value stored in a and visaversa
		Copiar/pasar la referencia significa que el cambio en B  afecta a que cambie A y viceversa
	In JS, primitives are passed by value, objects are passed by reference
		PRIMITIVES -> VALUE
		OBJECTS -> REFERENCE
 ->	"Under the hood", everything is actually passed by value.
 		The way of the objects  and primitives are stored in memory
 			Examples:
 				Primitives:
 					var a = 7
 					var b = a
 					Memory:		Diferentes memorias
 						a --> 7
 						b --> 7
 					b = 5
 					Memory:		No hay sobreescritura de memorias. VALUE
 						a --> 7
 						b --> 5
 				Objects
 					var a = {x:7}
 					var b = a 	Ahora B copia a A pero no su valor, si no hacia adonde apunta A
 					Memory 		Ambos apuntan a la misma memoria. REFERENCE
 						a --> 7 <-- b
 					b.x = 5
 					Memory 		b sobreescribe a la memoria a la que apunta, por lo que tambien sobreescribe la de a
 						a --> 5 <-- b
 				In both of them, b ends up with the same value as a






































