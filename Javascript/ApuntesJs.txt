Variables
	Empieza siempre por "var"
		var message = "Hello World";
		var palabra = "1";
	No se declaran tipos en Javascript: Int, String, float, etc.
		Es por eso que se le llama dinamic typed language
		Same variable can hold different types during the life of the execution

Funciones
	Estructura:
		function NAME () {}
		var NAME = function () {}
	Tambien se puede definir una funcion como variable, es lo mismo escribir:
			function a () {}
		que escribir
			var a = function () {}		Aqui no se pone el name
	Para invocar una funcion:
		NAME();
		a();
	Arguments/parametros:
		function compare (x, y){
		return x>y;
		}
	JS permite hacer lo siguiente:
		function compare (x, y) {}; 	Tenemos la funcion comparar x e y
		var a = compare (4, 5);			Comparamos 4 y 5 y lo guardamos en a
		compare (4, "a");				Comparamos 4 y a, que es el resultado de comparar 4 y 5
		compare();						No comparamos nada, pero la sintaxis es correcta

Scope
	Global
		Variables and function defined here are available everywhere
	Function (aka lexical)
		Variables and function defined here are available only within this function
	Scope Chain:
		Everything is executed in an Execution Context
		Function invocation creates a new Execution Context
		Each Execution Context has:
			Its own Variable Environment
			Special "this" object
			Reference to its Outer Environment
		Global scope does not have an Outer Environment as it's the most outer there is
		How it works Scope Chain:
			Referenced (not defined) variable will be searched for in its corrent scope first.
			If not found, the Outer Reference will be searched.
			if not found, the Outer Reference's Outer Reference will be searched.
			Etc
			This will keep going the Global scope.
			If not foun in GLobal scope, the variable is undefined.
		Example:
			Global
				var x = 2;
				A();
			Function A
				var x = 5;
				B();
			Function B
				console.log(x);
			The result printed is 2 porque la funcion B esta siendo llamada desde el Global, si fuese llamada(desde el inicio) en A, entonces el resultado seria 5.
			
JavasCript built-in Types (tipos integrados/incorporados en Javascript)
	A type is a particular data structure.
		Each language defines some built-in types.
		Built-in types can be used to build other data structures.
		Javascript has 7 built-in types: 6 primitives and 1 Object type
	Object is a collection of name/value pairs.
		Person object: (Ejemplo)
			firstname: 'Jose Luis', 	NAME(firstname) y VALUE(Jose Luis) 
			lastname: 'Gonzalez',		otro par de name/value
			social: {					NAME(social) y VALUE({lo de aqui dentro})
						linkedin : 'joseluisgonza',			otro par de name/value
						twitter: 'jolugo',					otro par de name/value
						facebook: 'JoseLuisGonalez',		otro par de name/value
					}
	Primitive type represents a single, inmutable value
		Single value, NOT an object
		Inmutable means once it's set, it can't be changed
			value becomes read-only
			you can create another value based on an exiting one
		Booleans: true or false
		Undefined: signifies that no value has ever been set
			you only have one value: undefined
			you can set a variable to undefined, but you should NEVER do it. 
				Its meaning is that it's never been defined, so defining it to undefined is counter to its core meaning
		Null: signifies lack of value
			as opposed to undefined, which is lack of definition
			can only have one value: null
			it's OK to explicitly set a variable to null
		Number: is the only numeric type in Javascript
			always represented under the hood as double-precision 64-bit floating point
			JS does not have an integer type
		String: is sequences of characters used to represent text
			use either single or double quotes. "text" or 'text'
	-->	Symbol: is new to ES6. 
			Not covered in this class
			ES6(realeased 2015) isn't widely supported or used yet

Common language constructs
	String concatination
		Podemos concatenar String con +=
			var palabra = "Hello";
			palabra += " ";
			palabra += "World";
			palabra += "!";					Es lo mismo que poner: palabra(Primer string, el de Hello) = palabra + " World!"
			console.log(palabra)				Resultado: Hello World!
			console.log(palabra + "!!!")		Resultado: Hello World!!!!
	Regular math operators
		+ - / *
		Tiene en cuenta todos los decimales:
			console.log((3*4)/233);		Resultado: 0.05150214592274678
		Si operamos con undefined, no da error, da un NaN(Not A Number)
			console.log(undefined/5);	Resultado: NaN
			Es comun definir una funcion que necesita una variable
				function test1(a){      
            		console.log(a/5)
        		}
        	Pero al llamar a la funcion no introducimos la variable y nos da como resultado NaN
        		test1();
        	OJO que no da error y nos deja correr JS
    Igualdad
    	== ===
    	Lo mismo que otros lenguajes
    		var x = 4, y = 4;					Esto es lo mismo que poner:
    		if (x == y) {							var x = 4;
        	console.log("x is equal to y")			var y = 4;
    		}				Resultado: x is equal to y
    	Pero, da igual el tipo de la variable que le hayamos asignado, JS modifica sus tipos para que sean iguales automaticamente
    		var y = 4;		Numero
    		var x = "4";	String
    		if (x == y) {
        		console.log("x is equal to y")
    		}				Resultado: x is equal to y
    	A no ser que queramos una igualdad estricta, con el triple igual, que entonces no variara sus tipos
    		var y = 4;		Numero
    		var x = "4";	String
    		if (x === y) {
        		console.log("X is equal to y")
    		}else{
        		console.log("X is NOT strict equal to y")
    		}				Resultado: X is NOT strict equal to y
    Verdadero o falso Boolean
    	Todo lo que JS considera false:
    		false
    		null
    		undefined
    		""			empty string
    		0
    		NaN
    	Todo lo que JS considera true:
    		true
    		"hello"
    		1
    		-1
    		"false"		This is a String with the word "false"
    	Si nos olvidamos podemos pasar por consola la siguiente orden:
    		Boolean(aqui ponemos nuestra duda);
    			Boolean(null);				false
    			Boolean(0);					false
    			Boolean("hey hey hey");		true
    Best practice for {} style
    	No se pone la apertura de llaves en una linea nueva, ya que da error. ya que es como poner un ;
    		function a() 			funntion a();
    		{
    			console.log("lo que sea")
    		}				Resultado: undefined
    	Se pone la apertura de llaves en la misma linea, y asi no da error.
    		function a() {
    			console.log("lo que sea")
    		}				Resultado: lo que sea
    Bucle FOR
    	Muy similar a Java:
    		for (var i = 0; i < 10; i++) {		de 0 a 9
        		ORDEN
    		}
    			i++ es lo mismo que i=i+1
    		for (var i = 0; i < 100; i=i*4) {		de 0 a 9
        		ORDEN
    		}
    Semicolons(;) in JS are optional
    	https://mislav.net/2010/05/semicolons/

Handling default values
	Si no metemos nada en una funcion obtenemos undefined
		function orderCHickeWith(sideDish) {
        	console.log("Chicken with " + sideDish)
    	}
    	orderCHickeWith("noodles")      //Chicken with noodles
    	orderCHickeWith()               //Chicken with undefined
    Para evitar el undefined podemos dar un valor por default
    	function orderCHickeWith(sideDish) {
        	if (sideDish === undefined) {
            	sideDish =  "nothing"
        	}
        	console.log("Chicken with " + sideDish)
    	}
    	orderCHickeWith("noodles")      //Chicken with noodles
    	orderCHickeWith()               //Chicken with nothing
    Pero JS tiene un shortcut para evitar poner el if
    	function orderCHickeWith(sideDish) {
        	sideDish = sideDish || "whatever!"      // El simbolo || es un OR
        	console.log("Chicken with " + sideDish)
    	}
    	orderCHickeWith("noodles")      //Chicken with noodles
    	orderCHickeWith()               //Chicken with whatever!
    Esto quiere decir que primero da el valor true:
    	Si sideDish = "" que es false
    		sideDish = sideDish || "whatever!"	-> false || true
    		usa "whatever!"
    	Si sideDish = 1 que es true
    		sideDish = sideDish || "whatever!"	-> true || true
    		usa 1
    	Es decir, utiliza SIEMPRE EL PRIMER TRUE







































